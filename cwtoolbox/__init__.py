# SPDX-FileCopyrightText: 2023 Stefan Hackenberg
#
# SPDX-License-Identifier: MIT

"""Cwtoolbox unifies access to ChipWhispererÂ®-Devices and other SCA trace sources."""

import contextlib
from pathlib import Path
from typing import Callable, Iterable, List, Optional, Tuple, Union

import numpy as np
import numpy.typing
import tqdm


class CaptureDevice:
    """A class used to capture traces from an external device."""

    def compile(
        self,
        file: Optional[Union[str, Path]] = None,
        code: Optional[str] = None,
        cflags: str = "",
        ldflags: str = "",
    ) -> None:
        """
        Compile given file or code string.

        Parameters
        ----------
        file
            The file to be compiled.
        code
            The code string to be compiled.
        cflags
            Compilation flags.
        ldflags
            Linking flags.

        Returns
        -------
        None

        """

    def flash(self, file: Optional[str] = None) -> None:
        """
        Flash compiled code to device.

        Parameters
        ----------
        file
            The file containing the compiled code to be flashed.

        Returns
        -------
        None

        """

    def reset_target(self) -> None:
        """
        Reset underlying device.

        Returns
        -------
        None

        """

    def connect(self) -> None:
        """
        Connect underlying device.

        Returns
        -------
        None

        """

    def disconnect(self) -> None:
        """
        Disconnect underlying device.

        Returns
        -------
        None

        """

    def capture(
        self,
        number_of_traces: int,
        input: Callable[[int], List[int]],
        number_of_samples: int = 0,
        read_output: bool = False,
    ) -> numpy.typing.NDArray:
        """
        Capture traces.

        Parameters
        ----------
        number_of_traces
            The number of traces to capture.
        input
            A callable that returns the input values for each trace.
        number_of_samples
            The number of samples to capture for each trace.
        read_output
            Whether to return the output generated by the device.

        Returns
        -------
        numpy.ndarray
            Array of traces where each trace contains an input array and a trace array.

        """
        data = np.empty(
            number_of_traces,
            dtype=[
                ("trace", "f8", (number_of_samples,)),
                ("input", "u1", (len(input(0)),)),
            ]
            + ([("output", "O", (1,))] if read_output else []),
        )
        with self.connected():
            self.reset_target()
            for i in tqdm.tqdm(range(number_of_traces)):
                data["input"][i, :] = input(i)
                trace, output = self.capture_single_trace(
                    number_of_samples,
                    data["input"][i, :],
                    read_output,
                )
                data["trace"][i, :] = trace
                if read_output:
                    data["output"][i] = output
        return data

    def capture_single_trace(
        self,
        number_of_samples: int,
        input: Iterable[int],
        read_output: bool = False,
    ) -> Tuple[numpy.typing.NDArray, Optional[bytes]]:
        """
        Capture one single trace.

        Parameters
        ----------
        number_of_samples
            The number of samples to capture.
        input
            A list of input values for each trace.
        read_output
            Whether to return the output generated by the device.

        Returns
        -------
        numpy.ndarray
            A trace.

        """
        list(input)
        return np.zeros(number_of_samples), b"" if read_output else None

    @contextlib.contextmanager
    def connected(self):
        """
        Execute code in connected state.

        Returns
        -------
        None

        """
        try:
            self.connect()
            yield
        finally:
            self.disconnect()

    @staticmethod
    def create(platform: str, **kwargs) -> "CaptureDevice":
        """
        Create a CaptureDevice instance based on the given platform.

        Parameters
        ----------
        platform
            The platform used for capturing traces.
        kwargs
            Additional keyword arguments.

        Returns
        -------
        CaptureDevice
            The CaptureDevice object.

        Raises
        ------
        NotImplementedError
            If the platform is invalid or unsupported.

        """
        if platform.startswith("CW"):
            # pylint: disable=import-outside-toplevel
            from .cw import CwCaptureSimpleSerial

            return CwCaptureSimpleSerial(platform)
        if platform.startswith("XMLRPCCW"):
            platform = platform.removeprefix("XMLRPC")
            # pylint: disable=import-outside-toplevel
            from .cw import (
                CwCaptureSimpleSerialRpcClient,
                CwCaptureSimpleSerialRpcClientResourceServer,
            )

            if "resource_server_uri" in kwargs:
                return CwCaptureSimpleSerialRpcClientResourceServer(
                    platform,
                    **kwargs,
                )

            return CwCaptureSimpleSerialRpcClient(platform, **kwargs)

        raise NotImplementedError(f"Unsupported Platform: {platform}")
